[
  {
    "title": "Datenmutation",
    "sections": [
      {
        "title": "Mutation",
        "type": "text",
        "content": "= das dynamische Verändern von flüchtigen Datenstrukturen\n**=>** Auf Zuweisungen von Variablen zurückzuführen",
        "picture": ""
      },
      {
        "title": "",
        "type": "list",
        "content": "in Funktionalen PS = non-feature (fehlend)",
        "picture": ""
      },
      {
        "title": "Vorteile - non-feature",
        "type": "list",
        "content": "wichtigstes non-feature eines Paradigmas\nCode schreiben ohne Befürchtung das anderer Code diesen beeinflusst\nSharing & Aliasing irrelevant\nz.B. Hinzufügen zu Listen -> Frage von Überschreibung hier irrelevant",
        "picture": ""
      },
      {
        "title": "Teile & Herrsche",
        "type": "text",
        "content": "",
        "picture": ""
      },
      {
        "title": "",
        "type": "list",
        "content": "in objektorientierte PL = nutzen Referenzsematik & Mutation -> Programmierer entscheiden wann nutzen altes Objekt & wann neues Objekt erzeugen\nneue Features OOPL = strukturierte unveränderte Wertetypen (z.B. readonly struct in C#, in Java nur experimentell)",
        "picture": ""
      },
      {
        "title": "Teile & Herrsche - Java",
        "type": "java",
        "content": "class ProtectedResource {\n    private Resource theResource = ...;\n    private String[] allowedUsers = ...;\n\n    public String[] getAllowedUsers() {\n        return allowedUsers;\n    }\n\n    public String currentUser() { ... }\n\n    public void useTheResource() {\n        for(int i=0; i < allowedUsers.length; i++) {\n        if(currentUser().equals(allowedUsers[i])) {\n            ... // access allowed: use it\n            return;\n        }\n        }\n        throw new IllegalAccessException();\n    }\n}\nr.getAllowedUsers()[0]=r.currentUser();",
        "picture": ""
      }
    ]
  },
  {
    "title": "Sprachen",
    "sections": [
      {
        "title": "Racket",
        "type": "text",
        "content": "= ungetypte & dynamisch getypte funktionale PL",
        "picture": ""
      },
      {
        "title": "Beispiel - Sum Liste - Racket",
        "type": "racket",
        "content": "(define sum\n  (lambda [lst]\n    (cond\n      [(empty? lst) 0] ; if list is empty return 0\n      [else (+ (first lst) ; take first element of list\n                (sum (rest lst)))] ; recursion\n    )\n  )\n)\n\n(define sumHigh (lambda [lst] (foldr + 0 lst))) ; usage of higher order\n(displayln (sum '(1 3 4 1))) ; 9\n(displayln (sumHigh '(1 3 4 1))) ; 9 ",
        "picture": ""
      },
      {
        "title": "Beispiel - Filter Liste - Racket",
        "type": "racket",
        "content": "(define filterNew \n  (lambda [ok? lst]\n    (cond\n      [(empty? lst) empty]\n      [(ok? (first lst)) (cons (first lst)  ; add first element of lst to builded list\n                                (filterNew ok? (rest lst)))] ; recursive for rest of list\n      [else (filterNew ok? (rest lst))]  ; recursive without adding list\n    )\n  )\n)\n\n(define filterHigh (lambda [ok? lst] (filter ok? lst)))\n(displayln (filterHigh (lambda (n) (>= n 10)) '(1 3 6 10 2 11))) ; (10 11)",
        "picture": ""
      },
      {
        "title": "Haskell",
        "type": "text",
        "content": "= streng, statisch, implizit, rein funktionale PL",
        "picture": ""
      },
      {
        "title": "Beispiel - Sum Liste - Haskell",
        "type": "code",
        "content": "-- sumNew :: Num a => [a] -> a\nsumNew lst =\n    if null lst\n        then 0\n        else head lst + sumNew (tail lst)",
        "picture": ""
      },
      {
        "title": "Beispiel - Filter Liste - Haskell",
        "type": "code",
        "content": "-- filterNew :: (a -> Bool, [a]) -> [a]\nfilterNew (ok, lst) =\n    if null lst then []\n    else if ok (head lst) \n        then head lst : filterNew (ok, tail lst)\n        else filterNew (ok, tail lst)",
        "picture": ""
      },
      {
        "title": "Beispiel Ausgaben - Terminal",
        "type": "terminalMacOS",
        "content": "sumNew [1, 2, 4, 3] -- call with list\n10\nfilterNew ((\\ x -> x <= 10), 2 : (10 : (13 : (3 : [])))) -- call with list\n[2,10,3]\nfilterNew ((\\ x -> x < 10), [2, 10, 13, 1, 20, 4]) -- call with list\n[2,1,4]",
        "picture": ""
      }
    ]
  },
  {
    "title": "Erste Schritte in Haskell",
    "sections": [
      {
        "title": "Einfache Definitionen",
        "type": "code",
        "content": "x :: Int -- Typdeklaration, optional\nx = 2 * 3 + 4\n-- y :: Int\ny = 2 * x -- Reihenfolge Deklarationen nicht relevant\n",
        "picture": ""
      },
      {
        "title": "Einfache Typen",
        "type": "code",
        "content": "i = 42 :: Int\nd1 = 1.0 :: Double\nd2 = -3.32e-7 :: Double\ns = \"abc\" :: String\nc = 'x' :: Char\nb1 = 2 == 2 :: Bool \nb2 = True || False :: Bool \n-- groß = Typen + Aufzählungskonstanten\n-- klein = Variablen (Konstanten, Funktionen)",
        "picture": ""
      },
      {
        "title": "Operatoren",
        "type": "code",
        "content": "-- Int:\n+ - * -- ACHTUNG: kein /\n< > <= => == /=  -- Bool'sche Optionen\n\n-- Double:\n+ - * /\n< > <= => == /= -- Bool'sche Optionen\n\n-- String:\n++ -- concat\n< > <= >= == /= -- Bool'sche Optionen\n\n-- Bool:\n&& || == /=\n\n-- weitere grafische Symbole benutzerdefinierbar\np ^ q = p /= q\n-- Operatorsymbole als Funktionsname verwendbar & umgekehrt\nadd = (+)\nr = (17 `div` 3) `mod` 4",
        "picture": ""
      },
      {
        "title": "Funktionen",
        "type": "code",
        "content": "-- Lambda-Ausdrücke\n\n-- f :: Int -> Int\nf = \\ x -> x + 1\n-- lambda Start mit \\\n-- danach Parameter, dann ->\n-- genau das gleiche wie:\ng :: Int -> Int\ng x = x + 1 \n\nj = (\\ x -> x + 1) 5\n-- Klammer wird auf 5 angewendet\n-- j -> 6\n-- genau das gleiche wie:\n-- f 5 & g 5\n\n---------------------------------\n\n-- Benennung von Funktionen\n\ntwice :: Int -> Int\ntwice = \\ x -> 2 * x\ny = 4\nz = twice y\n-- z -> 8",
        "picture": ""
      },
      {
        "title": "Rekursive Deklaration",
        "type": "code",
        "content": "-- Rekursive Defintion\n\nfacRec :: Int -> Int\nfacRec = \\ n -> if n == 0 then 1\n            else n * facRec (n - 1)\n-- facRec 5 -> 120\n\n-- Gebräuchlicher:\nfac :: Int -> Int\nfac n = if n == 0 then 1\n        else n * fac (n - 1)\n-- fac 5 -> 120\n\n--------------------------------------\n-- Haskell erlaubt auch (anscheinend)\n-- unsinnige Rekursion\nw = w + 1",
        "picture": ""
      },
      {
        "title": "",
        "type": "list",
        "content": "Parametertypen i.d.R. weggelassen\nRunde Klammern bei n = 1 i.d.R. weggelassen (d.h. nur 1 Parameter - auch bei Funktionsaufrufen)",
        "picture": ""
      },
      {
        "title": "Funktionsnotation & -aufruf",
        "type": "code",
        "content": "-- Beispiel - Funktionsnotation\npow (x, y) = \n    if y == 0 then 1\n    else x * pow (x, y - 1)\n\n-- Beispiel - Funktionsaufrufe\ncube x = pow (x, 3)\nfourcubed = cube 4\n-- fourcubed -> 64",
        "picture": ""
      },
      {
        "title": "Lokale Deklarationen",
        "type": "code",
        "content": "-- Syntax\n-- let {d1; ... ;dn} in e\n-- e where {d1; ... ;dn}\n\nsix = \n    let { next n = n + 1 }\n    in next 5 -- gilt lokal für next 5\n-- next 5 hier out of scope\n-- d.h. next 5 -> error\n\narea (a, b, c) = sqrt t\n    where {\n        t = s * (s - a) * (s - b) * (s - c);\n        s = ( a + b + c ) / 2\n    }\n-- heron's formular\n-- area (3, 3, 4) -> 4.47213595499958\n\n-- sqrt 25 -> 5",
        "picture": ""
      },
      {
        "title": "",
        "type": "list",
        "content": "Blockstrukturen {,; können weggelassen werden\nBlock vertikal über Einrückung (Vergleiche Syntax zu Python)",
        "picture": ""
      },
      {
        "title": "Zeilenwechsel mit ... Einrückungstiefe",
        "type": "list",
        "content": "dieselbe = Deklarationsende\ntiefere = Fortsetzung aktuellen Deklaration\nweniger = Blockende",
        "picture": ""
      },
      {
        "title": "Tupel",
        "type": "code",
        "content": "-- Paare & n-Tupel\npair = (1, \"abc\") :: (Int, String)\ntriple = (2, True, 1.0) :: (Int, Bool, Double)\nnested = (7, (True, 9)) :: (Int, (Bool, Int))\n\n-------------------------------------------------\n-- Komponentenzugriff\n-- get first element\na = fst pair -- 1\n-- get third element mit lokale Deklaration\nb = let (x, y, z) = triple in z -- 1.0\n-- get second element\nc = snd nested -- (True, 9)",
        "picture": ""
      },
      {
        "title": "Beispiel - Vergleich",
        "type": "text",
        "content": "",
        "picture": ""
      },
      {
        "title": "Div_Mod jeweils ganzzahlig - Haskell",
        "type": "code",
        "content": "div_mod :: (Int, Int) -> (Int, Int)\ndiv_mod (a, b) = (a `div` b, a `mod` b)\n-- div_mod (7,3) -> (2,1)",
        "picture": ""
      },
      {
        "title": "Div_Mod jeweils ganzzahlig - Java",
        "type": "java",
        "content": "public static void main (String args[]) {\n        int a = 7;\n        int b = 3;\n\n        int c = a / b;\n        int d = a % b;\n        System.out.println(c);\n        System.out.println(d);\n    }",
        "picture": ""
      },
      {
        "title": "Weiteres",
        "type": "text",
        "content": "",
        "picture": ""
      },
      {
        "title": "unit",
        "type": "code",
        "content": "-- () = Unit = leere Tupeltyp\n-- Infogehalt = 0 bit\n-- Typ von Variablen weniger nützlich\n-- für Belegung Typparametern in Grenzfällen\n-- Vergleiche zu void, empty Optional",
        "picture": ""
      },
      {
        "title": "Listen",
        "type": "code",
        "content": "-- Listenkonstruktion\nl0 = [] :: [Int] -- leere Liste vom Typ Int\nl1 = 1 : l0 :: [Int] -- 1 : [] -> [1], setzt Element vorne dran\nl2 = [1,2,3] :: [Int]\nl3 = [0,0] ++ l2 :: [Int] -- concat Listen -> [0,0,1,2,3]\nl4 = \"abc\" :: [Char] -- String zu Liste mit Char, \n-- wenn Typdeklaration als Liste -> ['a', 'b', 'c']\n-- type String = [Char]\n\n------------------------------------------------------------------\n-- Zugriffsoperationen\na = head l2 -- 1, erstes Element von l2\nb = tail l2 -- [2,3], alles außer erstes Element von l2\nc = l3 !! 2 -- 1, Listen-Index -> 3. Element von l3\nd = l4 !! 2 -- 'c'\ne = null l0 -- True, prüft ob Liste leer ist\nf = length l4 -- 3, Länge der Liste l4\n\n-------------------------------------------------------------------\n-- Funktionen über Listen\nsumNew :: [Int] -> Int\nsumNew lst =\n    if null lst then 0\n    else head lst + sumNew (tail lst)\n-- sumNew [1,3,2,5] -> 11\n\nappendNew :: ([Int], [Int]) -> [Int]\nappendNew (xs, xy) = \n    if null xs \n        then xy\n        else head xs : appendNew (tail xs, xy)\n-- appendNew ([1,4], [2,4,5,2]) -> [1,4,2,4,5,2]",
        "picture": ""
      },
      {
        "title": "Deklarative Listenkonstruktion",
        "type": "code",
        "content": "prices :: [Rational]\nprices = [10,30,17,20,15,18,45,12]\ntotalOfDiscountedPrices = sum [ p * 0.9 | p <- prices, p > 20]\n-- p <- prices = Zuweisung\n-- p > 20 = Condition\n-- p * 0.9 = Operation wenn Condition true\n-- sum = aufsummieren Liste\n-- totalOfDiscountedPrices -> 135 % 2",
        "picture": ""
      },
      {
        "title": "",
        "type": "list",
        "content": "normalerweise keine zustandsändernde Effekte\nFür Ausnahmen: do-Notation (Anwendungsfall: Experimentelle Tests ohne REPL)",
        "picture": ""
      },
      {
        "title": "Do-Notation",
        "type": "code",
        "content": "main = do \n    putStr \"Test 1: \"; print (1 + 1 == 2)\n    putStr \"Test 2: \"; print (length [1..10] == 10)\n-- main -> \n-- Test 1: True\n-- Test 2: True",
        "picture": ""
      }
    ]
  }
]